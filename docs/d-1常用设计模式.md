## 1.单例模式(构造器私有)

学习地址: [狂神单例模式 https://www.bilibili.com/video/BV1K54y197iS?spm_id_from=333.999.0.0&vd_source=737bc72ddc8b0e9190302e61a877a9d8](https://www.bilibili.com/video/BV1K54y197iS?spm_id_from=333.999.0.0&vd_source=737bc72ddc8b0e9190302e61a877a9d8)

这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

### 饿汉式单例模式

饿汉式单例模式是类加载的时候就调用构造函数,不论何时调用.但是如果对于类较多的时候比较占用空间

```java
public class HungrySingleton {

    //构造器私有
    private HungrySingleton() {

    }

    private final static HungrySingleton hungrySingleton = new HungrySingleton();

    public static HungrySingleton getInstance(){
        return hungrySingleton;
    }
}
```

### 懒汉式单例模式:单线程下正常,多线程下单例模式失效

```java
public class LazySingleton {

    //构造器私有
    private LazySingleton() {
        System.out.println(Thread.currentThread().getName() + "ok");
    }

    private static LazySingleton lazySingleton;

    public static LazySingleton getInstance(){
        if (lazySingleton == null){
            lazySingleton = new LazySingleton();
        }
        return lazySingleton;
    }
}
```

### 懒汉式单例模式:双重锁模式 DCL懒汉式

为LazySingleton.class类加锁

```java
public class LazySingleton {

    //构造器私有
    private LazySingleton() {
        System.out.println(Thread.currentThread().getName() + "ok");
    }

    private static LazySingleton lazySingleton;

    public static LazySingleton getInstance(){
        if (lazySingleton == null){
            synchronized (LazySingleton.class){
                if (lazySingleton == null){
                    lazySingleton = new LazySingleton();
                }
            }
        }
        return lazySingleton;
    }
}
```

### DCL懒汉式单例模式问题

此模式同样会出现问题,因为new LazySingleton(),其实会经历三个阶段

1. 分配类型空间
2. 调用构造方法,初始化对象
3. 将构造的对象指向分配的空间

可能会发生指令重排的操作,比如a线程首先执行1和3的操作,这个时候b线程进来了,然后经过判断发现lazySingleton不为null,则会进入

`return lazySingleton;`中,但是此时的对象还没有初始化,所以会发生异常,这个时候就需要`volatile`

```java
private volatile static LazySingleton lazySingleton;
```

保证指令不发生重排序

### 使用静态内部类实现单例模式

```java
public class Singleton {
    private Singleton(){}
    
    public static getInstance() {
        return SingletonHolder.INSTANCE;
    }
    
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton()
    }
}
```

### 反射机制破坏单例模式

```java
public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
    //无参构造器
    Constructor<LazySingleton> declaredConstructor = LazySingleton.class.getDeclaredConstructor(null);
    //无视私有方法
    declaredConstructor.setAccessible(true);
    LazySingleton lazySingleton1 = declaredConstructor.newInstance();
    LazySingleton lazySingleton2 = LazySingleton.getInstance();
    System.out.println(lazySingleton1);
    System.out.println(lazySingleton2);
}
```

通过以上代码发现,两个对象不相同,所以发射破坏了单例模式

解决方法

因为上面的反射是通过无参构造进入的,所以只要在无参构造中加入对lazySingleton是否为null的判断,同时为了防止两个对象都是通过无参构造创建的,那么就需要加入一个标志位,让只能第一次通过无参,因为正常情况下也是只通过一次无参构造函数.

```java
    private static boolean flag = false;
    //构造器私有
    private LazySingleton() {
        synchronized (LazySingleton.class){
            if (!flag){
                flag = true;
            }else {
                if (lazySingleton != null){
                    throw new RuntimeException("不要使用反射破坏单例模式");
                }
            }
        }
    }
```

### java枚举:是一个单例模式

java枚举没有无参构造函数,通过反射获取有参构造器,然后创建对象,会报反射异常的错误

## 2.工厂模式



## 3.适配器模式



## 4.装饰模式



## 5.策略模式



## 6.代理模式
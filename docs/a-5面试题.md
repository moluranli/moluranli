## 18. Java中的异常体系

**Java**的所有异常父类**Throwable**

**Throwable**有两个子类: **Exception**和**Error**

**Error**是错误,一旦出现,程序会自动停止

**Exception**的子类分类: **RunTimeException**和**CheckedException**

检测异常一般不会出现,**会导致编译过程中,编译不通过**

运行时异常在程序执行过程中,**一般导致线程执行失败**



## 19. GC如何判断垃圾回收

首先垃圾回收有**两种算法**:

- **引用计数法**: 如果这个对象**被其他对象所引用**,那么**引用计数加一**,**释放引用**的时候**引用减一**,如果**计数为0**,则代表此对象可以被**回收**

  > [!Tip]
  >
  > 如果A对象引用B对象,A对象引用计数加一,同时B对象应用A对象,B对象的计数加一,就会出现A对象和B对象都无法被回收的场面

- **可达性分析算法**: 有一个**GC Root**,当一个对象到**GC Root**没有引用链的时候,代表该对象可以被回收,Java的GC就是采用这种垃圾回收算法

  相关文章 :[GC Roots 是什么？哪些对象可以作为 GC Root？](https://blog.csdn.net/weixin_38007185/article/details/108093716)

  **GC Root**大概有一下4种类型

  1. 本地方法栈中**Native方法**引用的对象
  2. **虚拟机栈中**引用的对象
  3. 方法区**类静态属性**引用的对象
  4. 方法区中**常量**引用的对象

  <br>被**GC Root**不被引用的对象不一定一定要被回收: **GC Root**给了对象一次存活的机会

  第一次进行可达性分析的时候,对象会被标记

  第二次的时候,看对象是否覆盖了**finalize()**方法,如果没有覆盖,则直接回收,如果覆盖了,就会执行**finalize()方法**,然后再进行可达性分析



## 20. 线程的生命周期,线程的几种状态

线程的5种状态: **创建,就绪,运行,阻塞,死亡**

1. **创建**: 新建一个线程对象
2. **就绪**: 调用线程的`start()`方法,等待获取CPU的使用权
3. **运行**: 执行程序
4. **阻塞**
   1. **等待阻塞**: 调用了程序的`wait()` 方法,线程释放占用的资源,在等待池中,等待其他线程调佣`notify()`和`notifyAll()`方法后才被唤醒
   2. **同步阻塞**:线程在拿到同步锁的时候,同步锁被其他线程占用,线程进入锁池等待
   3. **其他阻塞**:线程执行了`sleep()`或`join()`方法,或者是I/O请求,当执行时间到了,就会让线程进入就绪状态.
5. **死亡**: 线程执行完毕,或者发生异常



## 21. wait(),sleep(),join(),yield()

**sleep()**和**wait()**的区别?

1. **sleep()**是**Thread**类中的静态方法,而**wait()**是**Object**中的方法
2. sleep不依赖于**synchornized**,而wait()依赖
3. sleep不会释放锁,而wait()会释放锁



yield()是释放锁之后是就绪状态,这就表示线程依然可以抢到CPU资源

join()执行之后,如果A调用B的join方法,那么A线程阻塞,直到B线程结束或者中断,A线程才可以运行





## 22. 看待线程安全问题

线程安全是指多个线程访问同一个对象的时候,都可以得到一个正确的结果,就是和单线程访问的时候可以得到同样的结果

jvm的栈就是线程安全的,每个线程拥有一块独立的栈内存

而jvm里面的堆就是线程不安全的,因为堆内存是线程共有的



## 23. Thread和Runable



## 24. 守护线程

守护线程就是为非守护线程提供服务的线程

守护线程不会守护单独的一个线程,他会守护JVM中的所有非守护线程,如果所有的非守护线程都运行完成之后,守护线程会自动的结束,不会受到自己的控制.

GC垃圾回收机制就是一个很典型的守护线程,当所有的线程都停止之后,就不会产生垃圾了,那么GC也就不用再次使用了,同是守护线程中创建的所有线程同样是守护线程



## 25. ThreadLocal的使用场景和原理

每一个**Thread**线程都有一个**ThreadLocalMap**类型的对象: **ThreadLocals**, 这里的entry存储的key为ThreadLocal对象,value存储的是用户自定义存储的值,同时entry是继承一个弱引用的一个类,因此如果没有强引用引用此对象,那么就会被垃圾回收

当用户使用set()函数的时候,ThreadLocal会想获取当前的线程对象,然后获取线程的ThreadLocalMap,然后通过ThreadLocal作为Key,自定义对象作为value进行存储,get()同理,每一个线程都有一个ThreadLocalMap,容器互不影响,所以没有线程安全问题

**使用场景:**

1. 在不同层之间进行传值,如果传递用户信息
2. 保存事务信息
3. 进行sql连接,Session会话管理
4. 线程间数据隔离

> [!Tip]
>
> Spring的jdbc connection就是通过ThreadLocal实现事务之间的隔离



## 26. ThreadLocal的内存泄漏问题

**内存泄漏**是该对象不会被使用,但是对象的内存却无法被回收

**产生原因**:

因为ThreadLocalMap的entry中的key:ThreadLocal是真正的弱引用对象,而entry实际上是强引用

